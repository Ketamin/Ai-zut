<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Maps with Leaflet</title>
  <link rel="stylesheet" href="leaflet-1.7.1/leaflet.css" />
  <script src="leaflet-1.7.1/leaflet-src.js"></script>
  <script src="leaflet-1.7.1/leaflet-providers.js"></script>
  <script src="leaflet-1.7.1/leaflet-image.js"></script>
  <style>
    #map {
      width: 300px;
      height: 300px;
      border: 1px solid black;
    }

    #rasterMap {
      width: 300px;
      height: 300px;
      border: 1px solid black;
    }

    #puzzleTable,
    #dropArea {
      display: grid;
      gap: 0;
      /* Ustawienie odstępu na 0 */
      justify-content: center;
      align-items: center;
    }

    #puzzleTable {
      grid-template-columns: repeat(8, 75px);
      grid-template-rows: repeat(2, 75px);
    }

    #dropArea {
      grid-template-columns: repeat(4, 75px);
      grid-template-rows: repeat(4, 75px);
    }

    .puzzlePiece,
    .dropSpot {
      width: 75px;
      height: 75px;
      border: 1px solid black;
    }

    .dropSpot {
      background-color: lightgray;
    }

    .dropSpot img {
      width: 75px;
      height: 75px;
      border: none;
      /* Usunięcie bordera */
    }
  </style>
</head>

<body>
  <div id="map"></div>
  <button id="getLocation">Get Current Location</button>
  <button id="saveButton">Save Raster Map</button>
  <br>
  <canvas id="rasterMap"></canvas>
  <div id="puzzleTable"></div>
  <div id="dropArea">
    <!-- This creates a 4x4 grid of drop spots -->
    <!-- Dodajemy atrybut data-occupied, który będzie modyfikowany w JavaScript -->

    <!-- TODO: remove data-x data-y -->
    <div class="dropSpot" data-x="0" data-y="0" data-occupied="false"></div>
    <div class="dropSpot" data-x="1" data-y="0" data-occupied="false"></div>
    <div class="dropSpot" data-x="2" data-y="0" data-occupied="false"></div>
    <div class="dropSpot" data-x="3" data-y="0" data-occupied="false"></div>
    <div class="dropSpot" data-x="0" data-y="1" data-occupied="false"></div>
    <div class="dropSpot" data-x="0" data-y="2" data-occupied="false"></div>
    <div class="dropSpot" data-x="0" data-y="3" data-occupied="false"></div>
    <div class="dropSpot" data-x="0" data-y="0" data-occupied="false"></div>
    <div class="dropSpot" data-x="0" data-y="0" data-occupied="false"></div>
    <div class="dropSpot" data-x="0" data-y="0" data-occupied="false"></div>
    <div class="dropSpot" data-x="0" data-y="0" data-occupied="false"></div>
    <div class="dropSpot" data-x="0" data-y="0" data-occupied="false"></div>
    <div class="dropSpot" data-x="0" data-y="0" data-occupied="false"></div>
    <div class="dropSpot" data-x="0" data-y="0" data-occupied="false"></div>
    <div class="dropSpot" data-x="0" data-y="0" data-occupied="false"></div>
    <div class="dropSpot" data-x="0" data-y="0" data-occupied="false"></div>


    <!-- Powtórz dla wszystkich pozostałych miejsc w gridzie -->
  </div>
  <script>
    const tileSize = 300 / 4;
    let pieces = [];

    let map = L.map('map').setView([53.430127, 14.564802], 18);
    L.tileLayer.provider('Esri.WorldImagery').addTo(map);
    let marker = L.marker([53.430127, 14.564802]).addTo(map);
    marker.bindPopup("<strong>Hello!</strong><br>This is a popup.");

    const dropSpots = document.querySelectorAll(".dropSpot");
    dropSpots.forEach((dropSpot, index) => {
      const x = index % 4;
      const y = Math.floor(index / 4);
      dropSpot.setAttribute('data-x', x);
      dropSpot.setAttribute('data-y', y);
      dropSpot.setAttribute('data-occupied', 'false');
    });

    function splitImage() {
      const rasterMap = document.getElementById("rasterMap");
      const rasterContext = rasterMap.getContext("2d");
      const puzzleTable = document.getElementById("puzzleTable");
      pieces = [];

      for (let x = 0; x < 4; x++) {
        for (let y = 0; y < 4; y++) {
          const pieceCanvas = document.createElement("canvas");
          pieceCanvas.width = tileSize;
          pieceCanvas.height = tileSize;
          const pieceContext = pieceCanvas.getContext("2d");

          pieceContext.drawImage(rasterMap, x * tileSize, y * tileSize, tileSize, tileSize, 0, 0, tileSize, tileSize);
          const pieceImage = document.createElement("img");
          pieceImage.src = pieceCanvas.toDataURL();
          pieceImage.draggable = true;
          pieceImage.classList.add("puzzlePiece");
          pieceImage.setAttribute('data-x', x);
          pieceImage.setAttribute('data-y', y);
          pieceImage.setAttribute('is-on-drop-area', 'false')

          pieces.push({ canvas: pieceCanvas, image: pieceImage, x, y, onBoard: false });
          puzzleTable.appendChild(pieceImage);
        }
      }
      setUpDragAndDrop(); // Ustawiamy drag and drop po stworzeniu kawałków puzzle
    }



    function setUpDragAndDrop() {
      const dropArea = document.getElementById("dropArea");

      pieces.forEach(piece => {
        piece.image.addEventListener("dragstart", function (e) {
          e.dataTransfer.setData("text/plain", `${piece.x},${piece.y}`);
        });
      });

      dropArea.addEventListener("dragover", function (e) {
        e.preventDefault();
      });

      dropArea.addEventListener("drop", function (e) {
        e.preventDefault();
        const target = e.target.closest(".dropSpot"); // Upewnij się, że targetem jest dropSpot

        // Jeżeli nic nie przenosimy na miejsce, gdzie już jest obrazek, to nic nie rób
        if (target && target.getElementsByTagName('img').length > 0) {
          return;
        }

        const draggedData = e.dataTransfer.getData("text/plain").split(',');
        const draggedImg = pieces.find(p => p.x === parseInt(draggedData[0]) && p.y === parseInt(draggedData[1])).image;
        // Sprawdzamy czy przenoszony element jest occupied i czy miejsce na ktore go przesuwamy jest occupied

        // Sprawdzamy czy element ktore przeciagamy jest juz occupied jezeli tak to znaczy ze
        // przeciagamy element z planszy na inne miesjce
        // wiec powinnismy stare occupied zmienic na false
        if (draggedImg.getAttribute('is-on-drop-area') === 'true') {
          const oldDropSpot = document.querySelector(`.dropSpot[data-x="${draggedImg.dataset.x}"][data-y="${draggedImg.dataset.y}"]`);
          oldDropSpot.dataset.occupied = 'false';
        }

        // Przenosimy obrazek
        if (target) {
          target.appendChild(draggedImg);
          draggedImg.dataset.x = target.dataset.x; // aktualizujemy pozycje x
          draggedImg.dataset.y = target.dataset.y; // aktualizujemy pozycje y
          draggedImg.setAttribute('is-on-drop-area', 'true'); // aktualizujemy atrybut is-on-drop-area
          target.dataset.occupied = 'true'; // aktualizujemy atrybut occupied
        }
        updateOccupiedAttributes(); // Aktualizujemy atrybuty occupied
        // Kontrola końca gry
        checkCompletion();
      });


    }

    function updateOccupiedAttributes() {
      const dropSpots = document.querySelectorAll('.dropSpot');
      dropSpots.forEach(dropSpot => {
        const hasImage = dropSpot.querySelector('img');
        if (hasImage) {
          dropSpot.style.border = 'none';
        } else {
          dropSpot.style.border = '1px solid black';
        }
      });
    }

    function checkCompletion() {
      const allPlacedCorrectly = pieces.every(piece => {
        const dropSpot = document.querySelector(`.dropSpot[data-x="${piece.x}"][data-y="${piece.y}"]`);
        return dropSpot && dropSpot.contains(piece.image);
      });
      if (allPlacedCorrectly) {
        window.alert("Congratulations! Puzzle completed successfully.");
      }
    }

    document.getElementById("saveButton").addEventListener("click", function () {
      leafletImage(map, function (err, canvas) {
        if (err) throw err;
        let rasterMap = document.getElementById("rasterMap");
        rasterMap.width = canvas.width; // Ustaw szerokość canvas na szerokość obrazu z mapy
        rasterMap.height = canvas.height; // Ustaw wysokość canvas na wysokość obrazu z mapy
        let rasterContext = rasterMap.getContext("2d");
        rasterContext.drawImage(canvas, 0, 0); // Narysuj obraz na całym canvas
        splitImage(); // Podziel obraz już po pełnym narysowaniu
      });
    });
  </script>
</body>

</html>